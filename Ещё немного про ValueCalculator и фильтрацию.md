Из преимуществ ValueCalculator-ов (мощнейших инструментов для погромистов вроде меня) - можно динамически отфильтровать полученный справочник и использовать его как источник для другого справочника.
На примере услуги по телерадиовещанию
Есть у нас такая штука как спутники (их мало, но там такое большое количество записей, что они до сих пор не идут через ВКУ получать/продлевать лицензии, предпочитают на бумаге по старинке, не осуждаю, а полностью их понимаю - попробуй заполни для 250 записей СМИ и не сбейся в дополнительных сведениях, да ещё в таймаут ЕПГУ попади, чтобы тебя не вышвырнуло и не нажми случайно начать сначала, когда заполнил 100 СМИ и осталось ещё 150 заполнить 1:1 как на сайте указано)
Так вот, на спутниках некоторых нужно указывать не все СМИ, что вообще есть в лицензии, а конкретные. И хоцца одни убрать, другие добавить, как делить на 2 части справочник?
Правильно, отфильтровать сформированный из повторяшки массив элементов, ну или из чего там будет формироваться справочник
```json
{
    "linkedValues": [
        {
            "version": 2,
            "argument": "result",
            "definition": {
                "expression1": "arg2 && arg3.size() == 0 ? 's109' : 's108'",
                "arg1": "'${s23c15}' != 'empty' ? asString('${s23c15}') : 'false'",
                "arg2": "asString('${s64c2.arguments.changeSmiOnly}').equals('1') && #arg1.equals('false') ? 'true' : 'false'",
                "arg3": "asList('${s134c0.[?(@.s134c3.id == 'include')]}')"
            }
        },
        {
            "version": 1,
            "argument": "smiList",
            "jsonLogic": {
                "if": [
                    {
                        "notEmpty": [
                            "answer.s134c0.value.[?(@.s134c3.id != 'exclude')]"
                        ]
                    },
                    "answer.s134c0.value.[?(@.s134c3.id != 'exclude')]",
                    "answer.s134c0.value"
                ]
            }
        },
        {
            "version": 2,
            "argument": "excludeSmiList",
            "definition": {
                "expression1": "arg1",
                "arg1": "asList('${s134c0.[?(@.s134c3.id == 'exclude' && @.s134c4 == 'false')]}')"
            }
        },
        {
            "version": 2,
            "argument": "showExclude",
            "definition": {
                "expression1": "arg1.size() > 0 ? 'show' : 'hide'",
                "arg1": "asList('${s134c0.[?(@.s134c3.id == 'exclude' && @.s134c4 == 'false')]}')"
            }
        }
    ]
}
```
Код приведённый выше давайте разберём:
## result
Аргумент, который определяет, на какой из экранов пойти дальше и вести заявителя
`arg1` - проверка наличия компонента, который может быть скрыт и не быть в ответах (чек-бокс мой зависимый от других двух, там только один может быть, посему скрываю другие два). Если он есть, тогда я получаю его значение как строку либо передаю строкой false
`arg2` - преобразую в строку значение моего огромного калькулятора s64c2, обращение к аргументу с именем changeSmiOnly, и если он равен 1 И arg1 равен false, тогда возвращаю строкой true либо false
`arg3` - получаю список, который из выпадающего списка фильтрую по компоненту s134c3, его атрибуту id на значение `include`
А вот вычисляю я следующее:
Если `arg2 == true` И `arg3.size() == 0`, т.е. список пустой, тогда я должен буду пойти на экран s109, в противном случае на экран s108
## smiList
Справочник, который формирует список для мультика с применением фильтра, но в 1 версии
`notEmpty` - проверка, что компонент не пустой
`answer.s134c0.value.[?(@.s134c3.id != 'exclude')]` - мы берём и фильтруем мой справочник на пустоту, если по компоненту `s134c3.id` есть значение, хотя бы одной записи в массиве, у которой в сохраняемом значении не будет `exclude` (всего там 2 значения - include или exclude)
Результат:
Если значение не пустое будет, тогда передаю такой справочник отфильтрованный в ответ smiList, иначе передаю весь список как он есть (такое возможно, когда ваще изменений нет и компонент `s134c3` отсутствует на экране)
## excludeSmiList и showExclude
Справочник, который формирует список для мультика с применением фильтра, но в 2 версии, а также правило для отображения такого справочника на экране
`arg1` - получение списка из повторяшки, только теперь фильтрация по 2 компонентам одновременно - `s134c3.id` и `s134c4` - выпадающему списку и чек-боксу
Почему так - чек-бокс появляется, когда `s134c3.id` содержит ответ `exclude`, и при его активации полностью скрывает выпадающий список и оставляет текстовое поле `s134c5`, а вот при попытках увязать выпадашку и со строкой приводит к ошибке, что структура абсолютно разная, и такое не прокатит, как ни крути
в `excludeSmiList` мы передаём такой список, даже если он пустой, вот как есть передаём
в `showExclude` мы передаём ответ - показывать его или нет, проверяя размер списка, если он больше 0, тогда передаём `show`, иначе `hide`

Текст это хорошо, но без картинок - ничто
Как выглядит содержимое моей повторяшки, которая рассматривается в примере:
![[s134c0 или повторяшка для фильтрации.png]]
Всегда будут на форме:
* s134c1_id, которое скрыто (туда записывается идентификатор цикла, который непонятно как генерируется)
* s134c2, но есть зависимость, когда он скрывается (`s134c4`)
Компонент `s134c3` - динамическая выпадашка - появляется когда в калькуляторе `s64c2` вычисленный аргумент `changeSmiOnly` будет равен 1, т.е. заявитель меняет список СМИ, а значит отобразить компонент, что же он там меняет - какое исключает, а какое добавляет
Компонент `s134c4` - чек-бокс - отображается в зависимости, когда s134c3 выбрали Исключается (`exclude`)
Компонент `s134c5` - типичная ~~стринга~~ строка - зависит от активации `s134c4`, который скрывает `s134c2`
# Как эти вычисления в дальнейшем работают с зависимостями
Непосредственно основной виновник торжества
![[Мультик динамический оригинальный.png]]
А вот какие были настройки
![[Настройки оригинального мультика.png]]
Можно заметить, что тут иначе передаются параметры для сохраняемого и отображаемого значений - такое прокатывает и работает корректно, если у нас есть источник, в котором все эти значения уже есть
Скажу сразу, что для мультика в мультике я такое не экспериментировал, посему ~~методом научного тыка~~ эмпирическим методом было получено, что так оно работает