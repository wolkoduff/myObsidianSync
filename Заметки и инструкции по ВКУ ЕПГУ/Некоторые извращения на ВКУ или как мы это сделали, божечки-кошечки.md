Я не знаю, что порой курят заказчики или что рождается в их фантазиях, головах, сознаниях, нужно подчеркнуть, но они просят от простых разработчиков ниибически-сложных реализаций
Одна из таковых - сделайте мультик из мультика, чтобы я сделал третий мультик, который я сформировал из второго мультика, который сформирован 1 мультиком, а он из справочника
![[Pasted image 20250612235313.png]]
Ну или менее шакальное качество 
![[Pasted image 20250612235334.png]]
Мемасики мемасиками, но мы переходим к делу, мы же серьёзные люди и пришли сюда за интересными кейсами как их прикручивать да реализовывать
У нас есть мультик **MultipleChoiceDictionary**, который заполняется через справочник с ЕСНСИ
![[Pasted image 20250612235516.png]]
Справочник сложный, т.к. у нас есть маппинг параметров
`nsi_licenses_type` - код справочника в ЕСНСИ
![[Pasted image 20250613000006.png]]
Как видим, у справочника 3 атрибута, а это уже больше 2-х, значит сложный справочник
Итак, идём дальше. Мульик-донор мы описали, теперяче нам нужно описать второй мультик, который должен быть сформирован из значений первого. В целом, такое можно провернуть, и оно сработает
![[Pasted image 20250613000206.png]]
Настоятельно рекомендую снимать галочку с проверкой значения на backend-е для исключения подмены, т.к. справочник может обновляться, а бэкенд держать тухляк и не даст получить услугу получателю
Но пойдём дальше. Итак, нам нужно для мультика прописать источник, отображаемое значение и сохраняемое
![[Pasted image 20250613000329.png]]
```json
{
   "value": "answer.c41.value.list"
}
```

>[!WARNING] ВАЖНА! UWAGA!
>Смею заметить, что любой мультик - это список, посему не просто `answer.c41.value`, а `answer.c41.value.list`

Отображаемое значение, идём по пути наименьшего сопротивления. Нам предлагают использовать originalItems, но в данном случае - это избыточно, посему берём как есть в списке, что передаём источником
![[Pasted image 20250613000545.png]]
Тоже самое и с сохраняемым значением
![[Pasted image 20250613000656.png]]
`dictionaryRefLabel` = `text`
`dictionaryRefCode` = `id`
Почему так:
Потому что компонент сложный состоит из 2-х значений: text и id, и неважно, как мы их обозвали, таково соглашение на ЕПГУ
В моём случае, который я рассматривал, мы этот мультик запихали в повторяшку, для чистоты эксперимента
И вот теперь мы в цикле переходим к формированию 3 мультика из второго
![[Pasted image 20250613001153.png]]
Судя по заголовку компонента, не сильно стоило заморачиваться, цель была достигнуть результат
И тут также история повторяется
![[Pasted image 20250613001245.png]]
```json
{
   "value": "answer.c9.value.list"
}
```
Но есть уже нюансы
![[Pasted image 20250613001330.png]]
![[Pasted image 20250613001351.png]]
Скажу сразу, возможно, что настройка "источник находится в цикле" избыточна, требует проверки, но сохранена потому, что так оно точно работает
Поскольку мы находимся в цикле, то каждая карточка повторяшки будет хранить свой c9, который и будет являться источником для формирования мультика 3 уровня из 2 (помним, что 1 - из данных ЕСНСИ