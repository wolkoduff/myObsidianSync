# Сделай мне мультик из мультика, чтобы был мультик который я сделал мультика
Я не знаю, что порой курят заказчики или что рождается в их фантазиях, головах, сознаниях, нужно подчеркнуть, но они просят от простых разработчиков ниибически-сложных реализаций
Одна из таковых - сделайте мультик из мультика, чтобы я сделал третий мультик, который я сформировал из второго мультика, который сформирован 1 мультиком, а он из справочника
![[Мультики.png]]
Ну или менее шакальное качество 
![[Мультики в HD.png]]
Мемасики мемасиками, но мы переходим к делу, мы же серьёзные люди и пришли сюда за интересными кейсами как их прикручивать да реализовывать
У нас есть мультик **MultipleChoiceDictionary**, который заполняется через справочник с ЕСНСИ
![[Оригинальный мультик с ЕСНСИ.png]]
Справочник сложный, т.к. у нас есть маппинг параметров
`nsi_licenses_type` - код справочника в ЕСНСИ
![[Маппинг ключа или поля id атрибута компонента.png]]
Как видим, у справочника 3 атрибута, а это уже больше 2-х, значит сложный справочник
Итак, идём дальше. Мультик-донор мы описали, теперяче нам нужно описать второй мультик, который должен быть сформирован из значений первого. В целом, такое можно провернуть, и оно сработает
![[Мультик второго уровня.png]]
*Настоятельно рекомендую снимать галочку с проверкой значения на backend-е для исключения подмены, т.к. справочник может обновляться*, а бэкенд держать тухляк и не даст получить услугу получателю
Но пойдём дальше. Итак, нам нужно для мультика прописать источник, отображаемое значение и сохраняемое
![[Ссылка на источник значений для мультика.png]]
```json
{
   "value": "answer.c41.value.list"
}
```

>[!WARNING] ВАЖНА! UWAGA!
>Смею заметить, что любой мультик - это список, посему не просто `answer.c41.value`, а `answer.c41.value.list`

Отображаемое значение, идём по пути наименьшего сопротивления. Нам предлагают использовать originalItems, но в данном случае - это избыточно, посему берём как есть в списке, что передаём источником
![[Отображаемое значение для заявителя.png]]
Тоже самое и с сохраняемым значением
![[Что передаём как сохраняемое.png]]
`dictionaryRefLabel` = `text`
`dictionaryRefCode` = `id`
Почему так:
* Потому что компонент сложный состоит из 2-х значений: text и id, и неважно, как мы их обозвали, таково соглашение на ЕПГУ
* В моём случае, который я рассматривал, мы этот мультик запихали в повторяшку, для чистоты эксперимента
И вот теперь мы в цикле переходим к формированию 3 мультика из второго
![[Мультик 3 уровня.png]]
Судя по заголовку компонента, не сильно стоило заморачиваться, цель была достигнуть результат
И тут также история повторяется
![[Ссылка на мультик 3 уровня из 2 уровня.png]]
```json
{
   "value": "answer.c9.value.list"
}
```
Но есть уже нюансы
![[Третий уровень из второго отображаемые значения.png]]
![[Третий уровень из второго сохраняемые значения.png]]
Скажу сразу, возможно, что настройка "источник находится в цикле" избыточна, требует проверки, но сохранена потому, что так оно точно работает (А если быть совсем точным и вспомнить, что третий уровень мы формируем по каждой карточке, то ответ на поверхности)
Поскольку мы находимся в цикле, то каждая карточка повторяшки будет хранить свой c9, который и будет являться источником для формирования мультика 3 уровня из 2 (помним, что 1 - из данных ЕСНСИ