Дома нужно проанализировать, как упростить формы и учесть выделение ограниченного радиочастотного спектра
Т.е. s75 относится к территории и частотам при исключении, а s76 влиять должен на свои частоты в случае добавления и радиочастотного спектра
Экран s77 никак не влияет у нас на конкурсные города, а надо подумать, как это организовать более правильно и корректно

---
При выделении в ограниченный радиочастотный ресурс - останутся ли конкурсные города - для радио касается только и эфирного вещания

Если концепция сменится на программную направленность - обязать заполнять без процентов направленность. Если же концепция не меняется - загружать договора на общем загрузчике, не изъябываемся по разным загрузчикам по формам

!!!
1) ~~Добавили причину изменение наимен.сми. указали сми, которое искл. И которое вносим. После этого просит заполнить  концепцию для искл. Сми (что не правильно) и прикрепить устав редакции, а для ноаго сми не просит заполнить концепцию. а также мы заполнили концепцию для старого сми, но концепция не вывелась а печатной форме~~
2) Симэнерго. Добавляю в универсальную наземное эфирное вещание, конкурсный город. Однако не запросил расчет зоны, фкк и пр.
3) ~~Если есть хоть одна с добавлением СМИ - на территорию вести~~
4) ~~При переходе к подписанию выдает ошибку (Ошибка правила перехода)~~
5) ~~Тестирую яркое, ТВунив, уступка и изм.территории и числ.населенич. одно СМИ редакция. Два раза просит прикрепить устав редакции~~
6) Дописать формирование pdf-файлов при изменении частот и территории~~, а также заполнение концепции в СМИ~~


Убрать из списка запросов, запросы, что с ошибкой обхода структуры, чтобы не мешались
По всем, где формировались - перезапросить с доформированием запросов, что не были сформированы при правильном обходе

> [!IMPORTANT]
> ЫЫЫЫ

> [!WARNING]
> ЫЫЫ

> [!Caution]
> ЫЫЫЫЫЫ

> [!NOTE]
> Записька

> [!DANGER]
>SSS

1) Создать башни (апгрейды, у нас есть Т1, надо сделать Т2 и Т3)
2) В папке с башнями добавляем папку Upgrades, куда помещаем апгрейднутые башни
3) В папке конфиг каждой башки добавляем ObjectValue
4) Переименовать в upgrade
5) Value указываем вручную новую версию башни, на которую будет меняться
6) В башне Т2 повторяем п. 2-4
7) Поскольку может выпасть ошибка, допиливаем GameController
	1) Оборачиваем скрипт for i, tower in pairs do в if tower:IsA("Model") then end
8) Дальше добавим логику для мышки, когда накрываем башню, что надо делать
	1) Добавляем переменную hoveredInstance = nil
	2) Добавляем переменную selectedTower = nil
	3) RunService.RenderStepped корректируем, вынося local result из-под условия полностью if towerToSpawn
	4) Если не towerToSpawn тогда hoveredInstance = result.Instance
	5) Если не result, тогда hoveredInstance = nil
	6) Если towerToSpawn, тогда hoveredInstance = nil
	7) Для отладки, выведем hoveredInstance через команду print(hoveredInstance)
9) Делаем кликабельными башенки, лог убираем
10) InputBegan идёт под нож
	1) if towerToSpawn оборачивается elseif hoveredInstance and input.UserInputType.MouseButton1 then
	```lua
		local model = hoveredInstance:FindFirstAncestorOfClass("Model")
		if model and model.Parent == workspace.MyWorld.Towers then
			selectedTower = model
		else
			selectedTower = nil
		end
		
	```
11) Создаём функцию отображения интерфейса апгрейда, скрываем фрейм и делаем видимым только когда выделили башню
```lua
local function toggleTowerInfo()
	if selectedTower then
		gui.Selection.Visible = true
		-- переносим показания в интерфейс по выбранной башенке
		local config = selectedTower.Config
		gui.Selection.Stats.Damage.Value.Text = config.Damage.Value
		gui.Selection.Stats.Range.Value.Text = config.Range.Value
		gui.Selection.Stats.Cooldown.Value.Text = config.Cooldown.Value
		gui.Selection.Title.TowerName.Text = selectedTower.Name
		gui.Selection.Title.TowerImage.Image = config.Image.Texture
	else
		gui.Selection.Visible = false
	end
end
```
12) После чего добавляем функцию в конце hoveredInstance and input.userInputType
13) Пилим код обработки нажатия кнопок апгрейда и прочих
	1) Когда нажали кнопку апгрейда
	   ```lua
gui.Selection.Action.Upgrade.Activated:Connect(function()
    if selectedTower then
	    local upgradeTower = selectedTower.Config.Upgrade.Value
		local allowedToUpgrade = requestTowerFunction:InvokeServer(upgradeTower.Name)
		
		if allowedToUpgrade then
			spawnTowerEvent:FireServer(upgradeTower.Name, selectedTower.PrimaryPart.CFrame, selectedTower)
		end 
	end
end) 
```
	2) В скрипте Tower допиливаем tower.Spawn, добавляя переменную previous
	3) в allowedToSpawn добавляем проверку previous
	   ```lua
	   local newTower
	   if previous then
		   previous:Destroy()
		   newTower = ReplicatedStorage.Towers.Upgrades[name]:Clone()
	   else
		   newTower = ReplicatedStorage.Towers[name]:Clone()
	   end if
```
	4) Фиксим баг: towerExists в CheckSpawn findFisrtChild дописываем true рекурсия поис
	5) После апгрейда резко отхватим ошибку, что у старой модели нет папки config (естественно, мы же снесли модельку из игры, но обращение не поправили), поэтому допишем код ещё и атаки башни
	   ```lua
	   if newTower and newTower.Parent then
		   tower.Attack(newTower, player)
	   end 
```
	6) Какие мы молодцы, что поправили ошибку, но осталась одна проблема: интерфейс остался старым и не обновился сразу же на актуальный, а если ещё раз нажать, то создастся дубликат, а не новая башня 
		1) сносим событие SpawnToTower из Events
		2) Создаём удалённую функцию SpawnTower
		3) Чтобы далеко не ходить, заменяем наш spawnTowerEvent на spawnTowerFunction, размещаем после объявления functions
		4) Поскольку событие стало функцией, меняем код
		   ```lua
		   spawnTowerFunction.OnServerInvoke = tower.Spawn
```
		5) В функции towerSpawn после coroutine.wrap пишем return newTower, в else return false
		6) В gameController также заменяем spawnTowerEvent на spawnTowerFunction
		7) Поскольку событий больше нет в нашем коде, удаляем всю строку events
		8) Находим в Upgrade.Activated:Connect нашу запись со спавном, меняем на InvokeServer и пишем, что возвращает в переменную selectedTower
		9) Во втором вхождении также заменяем, но возвращаем в локальную переменную local placedTower
		   ```lua
		   local placedTower = spawnTowerFunction:InvokeServer(upgradeTower.Name, selectedTower.PrimaryPart.CFrame, selectedTower)
		   if placedTower then
			   -- Тут код создания башни, т.е. placedTowers += 1
			   toggleTowerInfo()
		   end
```
		10) toggleTowerInfo() добавляем и в Upgrade.Activated
		11) Но нам нужно будет скрывать кнопку Upgrade, когда Т3 достигли
		12) Кнопки продажи и конфига скрываем, спецом
		13) После чего дописываем toggleTowerInfo()
		    ```lua
		    local upgradeTower = config:FindFirstChild("Upgrade)
		    if upgradeTower then
			    gui.Selection.Action.Upgrade.Visible = true
			    gui.Selection.Action.Upgrade.Title.Text = "Upgrade (" .. upgradeTower.Value.Config.Price.Value .. ")"
			else
				gui.Selection.Action.Upgrade.Visible = false
			end
```
14) Переходим к созданию радиуса атаки, точнее его визуализации
	1) После raycastResult создаём новую функцию:
	   ```lua
	   local function createRangeCircle(tower)
		   local range = tower.Config.Range.Value
		   local height = (tower.PrimaryPart.Size.Y / 2) + tower.Humanoid.HipHeight (если башни - чюваки)
		   local offset = CFrame.new(0, -height, 0)
			
			local p = Instance.new("Part")
			p.Name = "Range"
			p.Shape = Enum.PartType.Cylinder
			p.Material = Enum.Material.Neon
			p.Transparency = 0.9
			p.Size = Vector3.new(2, range * 2, range * 2)
			p.TopSurface = Enum.SurfaceType.Smooth
			p.BottomSurface = Enum.SurfaceType.Smooth
			p.CFrame = tower.PrimaryPart.CFrame * offset * CFrame.Angles(0, 0, math.rad(90))
			p.CanCollide = false
			p.Anchored = true
			p.Parent = workspace.Camera
	   end
```
	2) После этого в toggleTowerInfo добавляем только что созданную функцию сразу после if selectedTower then
	3) Это всё прекрасно, но надо удалять же, если перестали смотреть, поэтому
	4) workspace.Camera:ClearAllChildren в toggleTowerInfo перед if 